import * as fs from "fs";
import * as path from "path";
import * as prettier from "prettier";
import { glob } from "glob";

/**
 * Use this script to generate the routes file, which will give us type safety
 */

async function generateRoutesFile(paths: string[], outputFile: string) {
  const content = `// This file is generated automatically by scripts/generate-routes.ts
// Do not edit this file directly.
// To regenerate this file, run:
//   yarn generate-routes
// 
import { components, hooks, utils } from "~/lib/router/generouted-components";

// all paths get defined here...
export const routePaths = [${paths.map((path) => `"${path}"`).join(", ")}] as const;
export type Path = (typeof routePaths)[number];

// all params for any given path get defined here...
export type Params = {
  ${paths
    .filter((path) => hasParams(path)) // only include paths with params
    .map((path) => `"${path}": ${getParamsForPath(path)};`) // map each path to a string
    .join("\n  ")}
};

// Utility type to extract the leaf nodes of Params
type LeafNodes<T> = T[keyof T];

// Merge all leaf nodes into one big object type
type MergeLeafNodes<T> = UnionToIntersection<LeafNodes<T>>;

// Utility type to convert a union type to an intersection type
type UnionToIntersection<U> = 
  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;

// Combined type of all the leaf nodes
export type AllParams = MergeLeafNodes<Params>;

export const { Link, NavLink } = components<Path, Params>();
export const { useNavigate, useParams } = hooks<Path, Params>();
export const { redirect, generatePath } = utils<Path, Params>();
`;

  //  format the content
  const formattedContent = await prettier.format(content, {
    parser: "typescript",
  });

  // write the content to the file
  fs.writeFileSync(outputFile, formattedContent);
}

function hasParams(path: string): boolean {
  return path.includes(":");
}

function getParamsForPath(path: string): string {
  // required params start with ":"
  const requiredParams = path
    .split("/")
    .filter((part) => part.startsWith(":"))
    .map((part) => part.substring(1));

  if (requiredParams.length === 0) return "{}";

  return `{ ${requiredParams.map((param) => `"${param}": string`).join(", ")} }`;
}

function parsePath(inputPath: string): string | undefined {
  // remove everything after the last "."
  let path = inputPath.substring(0, inputPath.lastIndexOf("."));

  // test for "__foo" anywhere in the path
  // if found, only keep the part preceding it
  const doubleUnderscoreIndex = path.indexOf("__");
  if (doubleUnderscoreIndex !== -1) {
    path = path.substring(0, doubleUnderscoreIndex);
  }

  // replace all + with ""
  path = path.replace(/\+/g, "");

  // replace all "." with "/"
  path = path.replace(/\./g, "/");

  // replace all "$" with ":"
  path = path.replace(/\$/g, ":");

  // replace all "(:" with ":" and remove the immediately following ")"
  path = path.replace(/\(:/g, ":").replace(/\)/g, "");

  // replace all paths that are of the pattern _foo/ with ""
  path = path.replace(/_[^/]+/g, "");

  // replace all "index" with ""
  path = path.replace(/index/g, "");

  // replace any "WORD_/" with "WORD." (e.g. "drive_/" -> "drive/")
  path = path.replace(/_\//g, "/");

  // replace all "//" with "/"
  // MAYBETODO: fix why I have to do this twice
  path = path.replace(/\/\//g, "/");
  path = path.replace(/\/\//g, "/");

  // strip trailing "/"
  path = path.replace(/\/$/, "");

  // add leading "/", if needed
  if (!path.startsWith("/")) {
    path = `/${path}`;
  }

  // if the last two characters are "/:", return undefined
  if (path.endsWith("/:")) {
    return undefined;
  }

  return path;
}

async function parsePaths(paths: string[]) {
  const parsedPaths: string[] = [];

  const extraPathsToDo: string[] = [];

  for (const path of paths) {
    // we need to handle paths that contain "($"
    // for example,
    // when path = "($lang)._app.admin.edit.($assetId).tsx"
    // we want to add 3 extra paths to the list:
    // "_app.admin.edit.tsx"
    // "_app.admin.edit.($assetId).tsx"
    // "($lang)._app.admin.edit.tsx"
    // we need to handle paths that contain "($"
    const _path = path.replace(/\.tsx$/, "");
    const parts = _path.split(".");

    // identify indexes of dynamic segments (e.g., "($lang)")
    const dynamicIndexes = parts.map((part, i) => (/^\(\$(.+?)\)$/.test(part) ? i : null)).filter((i) => i !== null);

    // total number of combinations (include/exclude each dynamic param)
    const total = 1 << dynamicIndexes.length;

    for (let i = 0; i < total; i++) {
      const newParts = parts
        .map((part, index) => {
          const match = part.match(/^\(\$(.+?)\)$/);
          if (!match) return part; // keep static parts
          const dynamicIdx = dynamicIndexes.indexOf(index);
          return (i >> dynamicIdx) & 1 ? part : null; // keep or omit param
        })
        .filter(Boolean);

      // convert parts back to file-style path
      const extraPath = newParts.join(".") + ".tsx";
      extraPathsToDo.push(extraPath);
    }
    // ^^^^ end of handling paths that contain "($"

    // parse paths
    const parsedPath = parsePath(path);
    if (parsedPath) parsedPaths.push(parsedPath);
  }

  // go thru extraPathsToDo and parse them
  for (const path of extraPathsToDo) {
    const parsedPath = parsePath(path);
    if (parsedPath) parsedPaths.push(parsedPath);
  }

  // remove duplicates
  const uniquePaths = [...new Set(parsedPaths)];

  // sort alphabetically
  uniquePaths.sort();

  return uniquePaths;
}

/**
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

const routesDirectory = "./app/routes";
const outputFile = "./app/lib/router/routes.ts";

async function main() {
  const paths = await glob(`${routesDirectory}/**/*.{ts,tsx}`);
  // console.log(paths);
  const relativePaths = paths.map((file) => path.relative(routesDirectory, file));
  // console.log(relativePaths);
  const parsedPaths = await parsePaths(relativePaths);
  // console.log(parsedPaths);
  await generateRoutesFile(parsedPaths, outputFile);

  console.log(`âˆš Generated routes in ${outputFile}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
