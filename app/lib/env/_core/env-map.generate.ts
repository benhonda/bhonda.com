import { readdir, readFile } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const envDir = join(__dirname, "..");

async function generateServerEnvMap() {
  // Find all server env files (excluding defaults and generated files)
  const files = await readdir(envDir);
  const serverEnvFiles = files.filter(
    (file) => file.endsWith("-env.server.ts") && !file.includes(".defaults.") && !file.includes("all-server-env")
  );

  // Parse each file to find the actual export name
  const envModules: { file: string; exportName: string }[] = [];

  for (const file of serverEnvFiles) {
    const content = await readFile(join(envDir, file), "utf-8");
    // Look for export { someEnv };
    const exportMatch = content.match(/export\s*{\s*([\w]+)\s*}/);
    if (exportMatch) {
      envModules.push({
        file: file.replace(".ts", ""),
        exportName: exportMatch[1],
      });
    }
  }

  // Sort for consistent output
  envModules.sort((a, b) => a.file.localeCompare(b.file));

  // Generate imports
  const imports = envModules
    .map(({ file, exportName }) => {
      return `import { ${exportName} } from "./${file}";`;
    })
    .join("\n");

  // Generate the consolidated env object entries
  const envEntries = envModules
    .map(({ exportName }) => {
      return `    ...${exportName},`;
    })
    .join("\n");

  // Generate exports
  const exports = envModules
    .map(({ exportName }) => {
      return `  ${exportName},`;
    })
    .join("\n");

  const content = `//
//
// ‚ö†Ô∏è AUTO-GENERATED ‚Äî DO NOT EDIT
//
// 

/**
 * Consolidated server environment that merges all service-specific environments
 * 
 * This file is auto-generated by env-map.generate.ts
 */

${imports}

/**
 * Extract public environment variables from all sources
 * 
 * Public env vars are those that start with PUBLIC_
 */
export const getAllPublicEnv = () => {
  const allEnvs = {
${envEntries}
  };
  
  // Filter only PUBLIC_ prefixed variables
  return Object.fromEntries(
    Object.entries(allEnvs).filter(([key]) => key.startsWith("PUBLIC_"))
  );
};

/**
 * Export all server environments for easy access
 */
export {
${exports}
};`;

  // Write the generated file
  const outputPath = join(envDir, "all-server-env.ts");
  await Bun.write(outputPath, content);

  console.log(`‚úì Generated server env map with ${envModules.length} env files`);
}

async function generateClientEnvMap() {
  // Find all client env files
  const files = await readdir(envDir);
  const allClientEnvFiles = files.filter((file) => file.endsWith(".client.ts") && !file.includes("all-client-env"));

  // Separate defaults from regular files
  const defaultFiles = allClientEnvFiles.filter((f) => f.includes(".defaults."));
  const regularFiles = allClientEnvFiles.filter((f) => !f.includes(".defaults."));

  // Parse each file to extract window.env interface properties and export names
  const envVars = new Map<string, string>(); // var name -> description
  const envModules: { file: string; exportName: string }[] = [];

  // Process all files for env var extraction
  for (const file of allClientEnvFiles) {
    const content = await readFile(join(envDir, file), "utf-8");

    // Look for @env comments
    const envCommentMatches = content.matchAll(/@env\s+(PUBLIC_[A-Z_]+)\s*-\s*(.+)/g);
    for (const match of envCommentMatches) {
      const varName = match[1];
      const description = match[2];
      envVars.set(varName, description);
    }

    // Also look for direct references to window.env properties
    const windowEnvMatches = content.matchAll(/window\.env\??\.(PUBLIC_[A-Z_]+)/g);
    for (const match of windowEnvMatches) {
      const varName = match[1];
      if (!envVars.has(varName)) {
        envVars.set(varName, "");
      }
    }

    // Look for existing interface definitions (for backwards compatibility)
    const interfaceMatches = content.matchAll(/interface\s+Window\s*{[^}]*env\s*:\s*{([^}]*)}/gs);
    for (const match of interfaceMatches) {
      const interfaceContent = match[1];
      const propMatches = interfaceContent.matchAll(/(PUBLIC_[A-Z_]+)\s*\?\s*:\s*([^;]+);/g);
      for (const propMatch of propMatches) {
        const varName = propMatch[1];
        if (!envVars.has(varName)) {
          envVars.set(varName, "");
        }
      }
    }

    // Only add exports for non-default files
    if (!file.includes(".defaults.")) {
      const exportMatch = content.match(/export\s*{\s*([\w]+)\s*}/);
      if (exportMatch) {
        envModules.push({
          file: file.replace(".ts", ""),
          exportName: exportMatch[1],
        });
      }
    }
  }

  // Sort for consistent output
  envModules.sort((a, b) => a.file.localeCompare(b.file));

  // Generate imports
  const imports = envModules
    .map(({ file, exportName }) => {
      return `import { ${exportName} } from "./${file}";`;
    })
    .join("\n");

  // Generate interface properties
  const interfaceProperties: string[] = [];
  for (const [varName, description] of envVars) {
    if (description) {
      interfaceProperties.push(`      // ${description}`);
    }
    interfaceProperties.push(`      ${varName}?: string;`);
  }

  // Generate exports
  const exports = envModules.map(({ exportName }) => `  ${exportName},`).join("\n");

  const content = `//
//
// ‚ö†Ô∏è AUTO-GENERATED ‚Äî DO NOT EDIT
//
// 

/**
 * Consolidated client environment type declarations
 * 
 * This file is auto-generated by env-map.generate.ts
 */

${imports}

declare global {
  interface Window {
    env: {
${interfaceProperties.join("\n")}
    };
  }
}

/**
 * Export all client environments for easy access
 */
export {
${exports}
};`;

  // Write the generated file
  const outputPath = join(envDir, "all-client-env.ts");
  await Bun.write(outputPath, content);

  console.log(
    `‚úì Generated client env map with ${regularFiles.length} env files (${envVars.size} env vars from ${allClientEnvFiles.length} total files)`
  );
}

async function generateEnvExample() {
  // Collect all env vars from both server and client
  const envVars = new Map<
    string,
    {
      source: string;
      description: string;
      hasDefault?: boolean;
      defaultValue?: string;
      isOptional?: boolean;
      isComputed?: boolean;
      computedFrom?: string;
    }
  >();
  const files = await readdir(envDir);

  // Process server files (including defaults)
  const serverEnvFiles = files.filter(
    (file) => (file.endsWith("-env.server.ts") || file === "env.defaults.server.ts") && !file.includes("all-server-env")
  );

  for (const file of serverEnvFiles) {
    const content = await readFile(join(envDir, file), "utf-8");

    // Look for z.object definitions
    const schemaMatches = content.matchAll(/z\.object\s*\(\s*{([^}]+)}/gs);
    for (const match of schemaMatches) {
      const schemaContent = match[1];

      // Split into lines to preserve JSDoc comments
      const lines = schemaContent.split("\n");
      let currentComment = "";

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check for JSDoc comment
        const commentMatch = line.match(/^\s*\/\*\*\s*(.*)$/);
        if (commentMatch) {
          // Start of JSDoc comment
          currentComment = commentMatch[1];
          // Look for the closing */
          for (let j = i + 1; j < lines.length; j++) {
            const commentLine = lines[j];
            const endMatch = commentLine.match(/^\s*\*?\s*(.*?)\s*\*\/$/);
            if (endMatch) {
              if (endMatch[1]) currentComment = endMatch[1];
              i = j;
              break;
            } else {
              const middleMatch = commentLine.match(/^\s*\*\s*(.*)$/);
              if (middleMatch && middleMatch[1]) {
                currentComment = middleMatch[1];
              }
            }
          }
        }

        // Check for env var definition
        const varMatch = line.match(/^\s*([A-Z][A-Z0-9_]*)\s*:\s*z\./);
        if (varMatch) {
          const varName = varMatch[1];

          // Check for default or optional
          let hasDefault = false;
          let defaultValue = "";
          let isOptional = false;

          // Look for .default() in the schema definition
          if (line.includes(".default(")) {
            hasDefault = true;
            const defaultMatch = line.match(/\.default\(["']?([^"')]+)["']?\)/);
            if (defaultMatch) {
              defaultValue = defaultMatch[1];
            }
          }

          // Check if optional
          if (line.includes(".optional()")) {
            isOptional = true;
          }

          // Special handling for platform variables
          const platformVars = ["VERCEL_ENV", "NODE_ENV"];
          if (platformVars.includes(varName)) {
            envVars.set(varName, {
              source: file.replace("-env.server.ts", "").replace("env.defaults.server.ts", "defaults.server"),
              description:
                currentComment ||
                (varName === "NODE_ENV"
                  ? "Node.js environment (development, production, test) - automatically set by runtime/build tools"
                  : "Automatically set by deployment platform"),
              isComputed: true,
              computedFrom: varName === "NODE_ENV" ? "Node.js runtime/build tools" : "deployment platform",
              hasDefault: true,
              defaultValue,
            });
          } else {
            envVars.set(varName, {
              source: file.replace("-env.server.ts", "").replace("env.defaults.server.ts", "defaults.server"),
              description: currentComment,
              hasDefault,
              defaultValue,
              isOptional,
            });
          }
          currentComment = ""; // Reset comment after use
        }
      }
    }

    // Look for variable assignments before parse
    const varAssignments = new Map<string, string>();
    const assignmentMatches = content.matchAll(/const\s+(\w+)\s*=\s*([^;]+);/g);
    for (const match of assignmentMatches) {
      varAssignments.set(match[1], match[2].trim());
    }

    // Look for computed values in parse section
    const parseMatch = content.match(/\.parse\s*\(\s*{([^}]+)}\s*\)/s);
    if (parseMatch) {
      const parseContent = parseMatch[1];
      // Look for computed assignments like: APP_FQDN: someVariable
      const computedMatches = parseContent.matchAll(/^\s*([A-Z][A-Z0-9_]*)\s*:\s*(?!process\.env)([^,\n]+)/gm);
      for (const match of computedMatches) {
        const varName = match[1];
        const computedValue = match[2].trim();
        if (envVars.has(varName)) {
          const existing = envVars.get(varName)!;

          // Check if this is a variable reference
          if (varAssignments.has(computedValue)) {
            const actualValue = varAssignments.get(computedValue)!;

            // Check if the actual value references process.env for the same variable
            if (actualValue.includes(`process.env.${varName}`)) {
              // This is a conditional default
              if (
                actualValue.includes("development") &&
                (actualValue.includes("localhost:3000") ||
                  actualValue.includes("localhost:3001") ||
                  actualValue.includes("localhost:3002"))
              ) {
                existing.hasDefault = true;
                existing.defaultValue = "localhost:300[0|1|2] (in development only)";
                existing.description =
                  (existing.description ? existing.description + ". " : "") +
                  "Required in production, defaults to localhost:300[0|1|2] in development";
              }
            } else if (actualValue.includes("process.env.")) {
              // References a different env var - mark as computed
              existing.isComputed = true;
              existing.computedFrom = actualValue;
            } else {
              // Pure computed value
              existing.isComputed = true;
              existing.computedFrom = actualValue;
            }
          } else if (!computedValue.includes("process.env.")) {
            // Direct computed value
            existing.isComputed = true;
            existing.computedFrom = computedValue;
          }
        }
      }
    }

    // Also look for direct process.env references
    const processEnvMatches = content.matchAll(/process\.env\.([A-Z][A-Z0-9_]*)/g);
    for (const match of processEnvMatches) {
      const varName = match[1];
      if (!envVars.has(varName)) {
        // Special handling for known auto-set variables
        const platformVars: Record<string, string> = {
          VERCEL_ENV: "Vercel deployment platform",
          NODE_ENV: "Node.js runtime/build tools",
        };

        const isAutoSet = varName in platformVars;

        // Add descriptions for common env vars
        let description = "";
        if (varName === "VERCEL_ENV") {
          description = "Automatically set by Vercel deployment platform";
        } else if (varName === "NODE_ENV") {
          description =
            "Node.js environment (development, production, test) - automatically set by runtime/build tools";
        }

        envVars.set(varName, {
          source: file.replace("-env.server.ts", "").replace("env.defaults.server.ts", "defaults.server"),
          description,
          isComputed: isAutoSet,
          computedFrom: isAutoSet ? platformVars[varName] : undefined,
          // Don't set hasDefault for NODE_ENV - it's computed, not defaulted
        });
      }
    }
  }

  // Process client files for descriptions
  const clientEnvFiles = files.filter((file) => file.endsWith(".client.ts") && !file.includes("all-client-env"));

  for (const file of clientEnvFiles) {
    const content = await readFile(join(envDir, file), "utf-8");

    // Look for @env comments
    const envCommentMatches = content.matchAll(/@env\s+(PUBLIC_[A-Z_]+)\s*-\s*(.+)/g);
    for (const match of envCommentMatches) {
      const varName = match[1];
      const description = match[2];
      if (envVars.has(varName)) {
        const existing = envVars.get(varName)!;
        existing.description = description;
      } else {
        envVars.set(varName, {
          source: file.replace("-env.client.ts", "").replace("env.defaults.client.ts", "defaults.client"),
          description,
          hasDefault: false,
          defaultValue: "",
          isOptional: false,
          isComputed: false,
          computedFrom: undefined,
        });
      }
    }
  }

  // Define the type for environment variable info
  type EnvVarInfo = {
    source: string;
    description: string;
    hasDefault?: boolean;
    defaultValue?: string;
    isOptional?: boolean;
    isComputed?: boolean;
    computedFrom?: string;
  };

  // Categorize env vars
  const requiredVars: Array<[string, EnvVarInfo]> = [];
  const optionalVars: Array<[string, EnvVarInfo]> = [];
  const defaultVars: Array<[string, EnvVarInfo]> = [];
  const computedVars: Array<[string, EnvVarInfo]> = [];

  for (const [varName, varInfo] of envVars) {
    const entry: [string, typeof varInfo] = [varName, varInfo];
    // Computed takes priority (includes platform-set variables)
    if (varInfo.isComputed) {
      computedVars.push(entry);
    } else if (varInfo.hasDefault) {
      defaultVars.push(entry);
    } else if (varInfo.isOptional) {
      optionalVars.push(entry);
    } else {
      requiredVars.push(entry);
    }
  }

  // Generate .env.example content
  let content = `#
# ‚ö†Ô∏è AUTO-GENERATED .env.example ‚Äî DO NOT EDIT
#
# This file was automatically generated from the app's environment variable definitions.
# Copy this file to .env and fill in the required values.
#

`;

  // Add summary section
  content += `# üìä ENVIRONMENT VARIABLES SUMMARY
# ================================
# Required: ${requiredVars.length} variables (must be set)
# Optional: ${optionalVars.length} variables (can be left empty)
# With Defaults: ${defaultVars.length} variables (have default values if not set)
# Computed: ${computedVars.length} variables (automatically derived)
# Total: ${envVars.size} variables

`;

  // Helper function to format variable entry
  const formatVar = (name: string, info: EnvVarInfo) => {
    let result = "";

    // Add description
    if (info.description) {
      result += `# ${info.description}\n`;
    }

    // Add metadata
    const metadata: string[] = [];
    if (info.hasDefault && info.defaultValue) {
      metadata.push(`Default: ${info.defaultValue}`);
    } else if (info.hasDefault) {
      metadata.push("Has default");
    }
    if (info.isOptional) {
      metadata.push("Optional");
    }
    if (info.isComputed) {
      metadata.push(`Computed from: ${info.computedFrom}`);
    }
    if (metadata.length > 0) {
      result += `# [${metadata.join(", ")}]\n`;
    }

    // Add the variable
    result += `${name}=\n`;
    return result;
  };

  // Add required variables
  if (requiredVars.length > 0) {
    content += `\n# ‚ùó REQUIRED VARIABLES\n`;
    content += `# These must be set for the application to work properly\n`;
    content += `# =====================================================\n\n`;

    // Group by source
    const groupedRequired = new Map<string, Array<[string, EnvVarInfo]>>();
    for (const [name, info] of requiredVars) {
      if (!groupedRequired.has(info.source)) {
        groupedRequired.set(info.source, []);
      }
      groupedRequired.get(info.source)!.push([name, info]);
    }

    for (const [source, vars] of Array.from(groupedRequired.entries()).sort()) {
      content += `# --- ${source.replace("-", " ").toUpperCase()} ---\n`;
      for (const [name, info] of vars.sort()) {
        content += formatVar(name, info);
      }
      content += `\n`;
    }
  }

  // Add optional variables
  if (optionalVars.length > 0) {
    content += `\n# üí° OPTIONAL VARIABLES\n`;
    content += `# These can be left empty if not needed\n`;
    content += `# =====================================\n\n`;

    for (const [name, info] of optionalVars.sort()) {
      content += formatVar(name, info);
    }
    content += `\n`;
  }

  // Add variables with defaults
  if (defaultVars.length > 0) {
    content += `\n# üîß VARIABLES WITH DEFAULTS\n`;
    content += `# These have default values and only need to be set if you want to override them\n`;
    content += `# ==============================================================================\n\n`;

    for (const [name, info] of defaultVars.sort()) {
      content += formatVar(name, info);
    }
    content += `\n`;
  }

  // Add computed variables
  if (computedVars.length > 0) {
    content += `\n# ü§ñ COMPUTED VARIABLES\n`;
    content += `# These are automatically set based on other values - DO NOT SET MANUALLY\n`;
    content += `# ======================================================================\n\n`;

    for (const [name, info] of computedVars.sort()) {
      content += `# ${formatVar(name, info).replace(/\n$/, " (AUTO-SET - DO NOT MODIFY)\n")}`;
    }
  }

  // Write .env.example at project root
  const outputPath = join(__dirname, "../../../../.env.example");
  await Bun.write(outputPath, content);

  console.log(`‚úì Generated .env.example with ${envVars.size} environment variables`);
}

// Run all generators
await generateServerEnvMap();
await generateClientEnvMap();
await generateEnvExample();
